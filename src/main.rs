#[macro_use]
extern crate pest_derive;

#[macro_use]
extern crate lazy_static;

mod parser;
use parser::parse_source;

mod ast;
use ast::analyze_top_level;

mod codegen;

use std::fs;

use clap::Clap;

use std::process;

use normalize_line_endings::normalized;
use std::iter::FromIterator;

mod python;

#[derive(Clap)]
#[clap(version = "1.0", author = "Ramsey Nasser <ram@nas.sr>")]
struct Opts {
    #[clap(subcommand)]
    subcommand: SubCommand,
}

#[derive(Clap)]
enum SubCommand {
    /// Compile an OSKAR file
    Compile(CompileOpts),
    /// Print the version of the compiler
    Version,
}

#[derive(Clap)]
struct CompileOpts {
    /// The file to compile
    file: String,
}

// maybe move to codegen
fn comment_string(s: &str) -> String {
    let mut ret = "# ".to_string();
    ret.push_str(&s.replace("\n", "\n# "));
    ret
}

fn compile(path: String) {
    let source = fs::read_to_string(&path).expect("cannot read file");
    // let source_no_comments = comment_re.replace_all(&source, "");
    let source_normalized = String::from_iter(normalized(source.chars()));
    let mut output = String::new();
    match parse_source(&source_normalized) {
        Err(e) => {
            // parse error
            eprintln!("{}", e.with_path(&path));
            process::exit(1);
        }
        Ok(pairs) => {
            output.push_str(&format!(
                "### generated by the OSKAR compiler {} ({}/{}, {})\n",
                env!("GIT_TAG"),
                env!("GIT_BRANCH"),
                env!("GIT_HASH"),
                env!("BUILD_DATE")
            ));
            output.push_str(&format!("### using python {}\n", python::version()));
            output.push_str(&format!("### from {}\n\n", path));

            output.push_str(&format!("{}", codegen::preamble()));

            for pair in pairs {
                let source = pair.as_str().trim_end();
                match analyze_top_level(pair.clone()) {
                    Ok(ast) => {
                        let python = codegen::to_python_source(&ast);
                        match ast {
                            ast::TopLevel::PythonCodeBlock(_) => {
                                output.push_str(&format!("\n{}\n", python))
                            }
                            ast::TopLevel::Skip => {}
                            _ => output.push_str(&format!(
                                "\n{}\n\n{}\n\n",
                                comment_string(source),
                                python
                            )),
                        }
                    }
                    Err(error) => {
                        let pair_line = pair.line_col().0;
                        // analysis error
                        eprintln!("{}", error.with_file(&path).adjust_line(pair_line));
                        process::exit(1);
                    }
                }
            }

            print!("{}", output);
        }
    }
}

fn version() {
    println!(
        "OSKAR compiler {} ({}/{}, {})",
        env!("GIT_TAG"),
        env!("GIT_BRANCH"),
        env!("GIT_HASH"),
        env!("BUILD_DATE")
    );
    println!("using python {}", python::version())
}

fn main() {
    let opts = Opts::parse();
    match opts.subcommand {
        SubCommand::Compile(c) => compile(c.file),
        SubCommand::Version => version(),
    }
}
