#[macro_use]
extern crate pest_derive;

#[macro_use]
extern crate lazy_static;

mod parser;
use parser::parse_source;

mod ast;
use ast::analyze_top_level;

mod codegen;

use std::fs;

use clap::Clap;

use std::process;

use normalize_line_endings::normalized;
use std::iter::FromIterator;

mod python;

#[derive(Clap)]
#[clap(version = "1.0", author = "Ramsey Nasser <ram@nas.sr>")]
struct Opts {
    #[clap(subcommand)]
    subcommand: SubCommand,
}

#[derive(Clap)]
enum SubCommand {
    /// Compile an OSKAR file
    Compile(CompileOpts),
    /// Print the version of the compiler
    Version,
}

#[derive(Clap)]
struct CompileOpts {
    /// The file to compile
    file: String,
}

// maybe move to codegen
fn comment_string(s: &str) -> String {
    let mut ret = "# ".to_string();
    ret.push_str(&s.replace("\n", "\n# "));
    ret
}

// TODO move into ast
fn get_line_col(source: &str, offset: usize) -> Option<(usize, usize)> {
    let mut line_number = 1;
    let mut current_offset = 0;

    for line in source.lines() {
        let line_length = line.len() + 1;
        if current_offset + line_length > offset {
            return Some((line_number, offset - current_offset));
        }
        line_number += 1;
        current_offset += line_length;
    }

    None
}

fn compile(path: String) {
    let source = fs::read_to_string(&path).expect("cannot read file");
    // let source_no_comments = comment_re.replace_all(&source, "");
    let source_normalized = String::from_iter(normalized(source.chars()));
    let mut output = String::new();
    match parse_source(&source_normalized) {
        Err(e) => {
            // parse error
            eprintln!("parse error\n{}", e.with_path(&path));
            process::exit(1);
        }
        Ok(pairs) => {
            output.push_str(&format!(
                "### generated by the OSKAR compiler {} ({}/{}, {})\n",
                env!("GIT_TAG"),
                env!("GIT_BRANCH"),
                env!("GIT_HASH"),
                env!("BUILD_DATE")
            ));
            output.push_str(&format!("### using python {}\n", python::version()));
            output.push_str(&format!("### from {}\n\n", path));

            output.push_str(&format!("{}", codegen::preamble()));

            for pair in pairs {
                let source = pair.as_str().trim_end();
                match analyze_top_level(pair.clone()) {
                    Ok(ast) => {
                        let python = codegen::to_python_source(&ast);
                        match ast {
                            ast::TopLevel::PythonCodeBlock(_) => {
                                output.push_str(&format!("\n{}\n", python))
                            }
                            ast::TopLevel::Skip => {}
                            _ => output.push_str(&format!(
                                "\n{}\n\n{}\n\n",
                                comment_string(source),
                                python
                            )),
                        }
                    }
                    Err(error) => {
                        // TODO this is a mess, but analysis errors should be very rare
                        let (ll, cc) = get_line_col(&source_normalized, error.span.0).unwrap();
                        let line_from_source = source_normalized.lines().nth(ll - 1).unwrap();
                        let ccc = error.column_number + cc;
                        eprintln!(
                            "analysis error\n{}",
                            error
                                .with_file(&path)
                                .with_line(line_from_source)
                                .with_line_number(ll)
                                .with_column_number(ccc)
                        );
                        process::exit(1);
                    }
                }
            }

            print!("{}", output);
        }
    }
}

fn version() {
    println!(
        "OSKAR compiler {} ({}/{}, {})",
        env!("GIT_TAG"),
        env!("GIT_BRANCH"),
        env!("GIT_HASH"),
        env!("BUILD_DATE")
    );
    println!("using python {}", python::version())
}

fn main() {
    let opts = Opts::parse();
    match opts.subcommand {
        SubCommand::Compile(c) => compile(c.file),
        SubCommand::Version => version(),
    }
}
