#[macro_use]
extern crate pest_derive;

#[macro_use]
extern crate lazy_static;

mod parser;
use parser::parse_source;

mod ast;
use ast::analyze_top_level;

mod codegen;

use std::fs;

use clap::Clap;

use std::process;

use normalize_line_endings::normalized;
use regex::Regex;
use std::iter::FromIterator;

mod py_codegen;

#[derive(Clap)]
#[clap(version = "1.0", author = "Ramsey Nasser <ram@nas.sr>")]
struct Opts {
    #[clap(subcommand)]
    subcommand: SubCommand,
}

#[derive(Clap)]
enum SubCommand {
    /// Compile an OSKAR file
    Compile(CompileOpts),
    /// Print the AST of a Python file (for debugging)
    Reverse(ReverseOpts),
    /// Print the version of the compiler
    Version,
    PythonTest,
}

#[derive(Clap)]
struct CompileOpts {
    /// The file to compile
    file: String,
}

#[derive(Clap)]
struct ReverseOpts {
    /// The file to reverse compile
    file: String,
}

// maybe move to codegen
fn comment_string(s: &str) -> String {
    let mut ret = "# ".to_string();
    ret.push_str(&s.replace("\n", "\n# "));
    ret
}

fn compile(path: String) {
    let comment_re = Regex::new(r"\s*#.*").unwrap();
    let source = fs::read_to_string(&path).expect("cannot read file");
    let source_no_comments = comment_re.replace_all(&source, "");
    let source_normalized = String::from_iter(normalized(source_no_comments.chars()));
    let mut output = String::new();
    match parse_source(&source_normalized, &path) {
        Err(e) => {
            println!("{}", e.with_path(&path));
            process::exit(1);
        }
        Ok(pairs) => {
            output.push_str(&format!(
                "### generated by the OSKAR compiler {} ({}/{}, {})",
                env!("GIT_TAG"),
                env!("GIT_BRANCH"),
                env!("GIT_HASH"),
                env!("BUILD_DATE")
            ));
            output.push_str(&format!("### from {}\n", path));

            output.push_str(&format!("{}", codegen::preamble()));

            for pair in pairs {
                let source = pair.as_str().trim_end();
                match analyze_top_level(pair) {
                    Ok(ast) => {
                        let python = codegen::to_python_source(&ast);
                        match ast {
                            ast::TopLevel::PythonCodeBlock(_) => {
                                output.push_str(&format!("{}", python))
                            }
                            ast::TopLevel::Skip => {}
                            _ => {
                                output.push_str(&format!("{}\n{}", comment_string(source), python))
                            }
                        }
                    }
                    Err(error) => {
                        println!("{}", error.with_path(&path));
                        process::exit(1);
                    }
                }
            }

            print!("{}", output);
        }
    }
}

fn reverse(path: String) {
    let source = fs::read_to_string(&path).expect("cannot read file");
    codegen::print_python_ast(&source)
}

fn version() {
    println!(
        "OSKAR compiler {} ({}/{}, {})",
        env!("GIT_TAG"),
        env!("GIT_BRANCH"),
        env!("GIT_HASH"),
        env!("BUILD_DATE")
    );
}

fn main() {
    let opts = Opts::parse();
    match opts.subcommand {
        SubCommand::Compile(c) => compile(c.file),
        SubCommand::Reverse(c) => reverse(c.file),
        SubCommand::Version => version(),
        SubCommand::PythonTest => python_test(),
    }
}

use pyo3::prelude::*;

fn py_if<'a>(
    ast: &'a PyAny,
    test: &PyAny,
    body: Vec<&PyAny>,
    orelse: Vec<&PyAny>,
) -> PyResult<&'a PyAny> {
    ast.getattr("If").unwrap().call1((test, body, orelse))
}

fn py_expr<'a>(ast: &'a PyAny, expr: &PyAny) -> PyResult<&'a PyAny> {
    ast.getattr("Expr").unwrap().call1((expr,))
}

fn py_name<'a>(ast: &'a PyAny, name: &str) -> PyResult<&'a PyAny> {
    ast.getattr("Name").unwrap().call1((name,))
}

fn py_call<'a>(ast: &'a PyAny, func: &PyAny, args: Vec<&PyAny>) -> PyResult<&'a PyAny> {
    ast.getattr("Call")
        .unwrap()
        .call1((func, args, Vec::<&PyAny>::new()))
}

fn py_constant<'a>(ast: &'a PyAny, value: &PyAny) -> PyResult<&'a PyAny> {
    ast.getattr("Constant").unwrap().call1((value,))
}

fn python_test() {
    let good_code = "
def test_good_parse(x):
    if x > 10:
        return (x + 2)
    else:
        return jj
    ";

    let bad_code = "
def test_bad_parse(x):
    if x > 10:
        return (x + 2
    else:
        return jj
    ";

    println!("# test python version");
    
    Python::with_gil(|py| {
        let sys = py.import("sys").unwrap();
        let ast = py.import("ast").unwrap();
        let unparse = ast.getattr("unparse").unwrap();

        let version: String = sys.getattr("version").unwrap().extract().unwrap();
        let path: Vec<String> = sys.getattr("path").unwrap().extract().unwrap();
        println!("Python Version {}", version);
        println!("Python Path {:?}", path);
        println!("AST Module {}", ast);
    });

    println!("# test parsing");

    match py_codegen::parse(good_code) {
        Ok(ast) => println!("{}\nok", py_codegen::unparse(&ast)),
        Err(e) => {
            println!("{}\nerror {:?}", good_code, e);
        },
    };

    match py_codegen::parse(bad_code) {
        Ok(ast) => println!("{}\nok", py_codegen::unparse(&ast)),
        Err(e) => {
            println!("{}\nerror {:?}", bad_code, e);
        },
    };

    println!("# test codegen");

    py_codegen::test_macros();    
}
