#[macro_use]
extern crate pest_derive;

mod parser;
use parser::parse_source;

mod ast;
use ast::analyze_top_level;

mod codegen;

use std::fs;
use std::path::Path;

use clap::Clap;

#[derive(Clap)]
#[clap(version = "1.0", author = "Ramsey Nasser <ram@nas.sr>")]
struct Opts {
    #[clap(subcommand)]
    subcommand: SubCommand,
}

#[derive(Clap)]
enum SubCommand {
    /// Compile an OSKAR file
    Compile(CompileOpts),
    /// Print the AST of a Python file (for debugging)
    Reverse(ReverseOpts),
}

#[derive(Clap)]
struct CompileOpts {
    /// The file to compile
    file: String,
}

#[derive(Clap)]
struct ReverseOpts {
    /// The file to reverse compile
    file: String,
}

// maybe move to codegen
fn comment_string(s: &str) -> String {
    let mut ret = "# ".to_string();
    ret.push_str(&s.replace("\n", "\n# "));
    ret
}

fn compile(path: String) {
    let source = fs::read_to_string(&path).expect("cannot read file");
    let pairs = parse_source(&source, &path);
    let name = Path::new(&path).file_stem().unwrap().to_str().unwrap();
    println!(
        "### generated by the OSKAR compiler {} ({}/{}, {})",
        env!("GIT_TAG"),
        env!("GIT_BRANCH"),
        env!("GIT_HASH"),
        env!("BUILD_DATE")
    );
    println!("### from {}\n", path);

    println!("{}", codegen::preamble());

    for pair in pairs {
        let source = pair.as_str();
        match analyze_top_level(pair) {
            ast::TopLevel::Skip => (),
            ast::TopLevel::PythonCodeBlock(code) => println!("{}", code.lines),
            x => {
                println!("{}", comment_string(source.trim_end()));
                let python = codegen::to_python_source(x);
                println!("{}", python);
            }
        }
    }
}

fn reverse(path: String) {
    let source = fs::read_to_string(&path).expect("cannot read file");
    codegen::print_python_ast(&source)
}

fn main() {
    let opts = Opts::parse();
    match opts.subcommand {
        SubCommand::Compile(c) => compile(c.file),
        SubCommand::Reverse(c) => reverse(c.file),
    }
}
